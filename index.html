<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Baby Monitor</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Libraries -->
<script src="https://cdn.jsdelivr.net/npm/qrcodejs/qrcode.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>

<style>
body { font-family: sans-serif; text-align: center; background: #fafafa; margin: 0; padding: 1em; }
video { width: 90%; max-width: 480px; margin: 1em auto; display: block; background: black; border-radius: 6px; }
button { margin: 0.5em; padding: 0.7em 1.2em; border: none; background: #007bff; color: white; border-radius: 6px; cursor: pointer; }
button:hover { background: #005ec2; }
#qr { margin-top: 1em; }
textarea { width: 90%; height: 100px; margin-top: 1em; }
</style>
</head>

<body>
<h2>ðŸ“· Baby Monitor</h2>
<button id="cameraBtn">Start Camera Mode</button>
<button id="monitorBtn">Start Monitor Mode</button>

<video id="localVideo" autoplay muted playsinline></video>
<video id="remoteVideo" autoplay playsinline></video>

<div id="qr"></div>
<button id="prevQR" style="display:none;">â—€ Previous QR</button>
<button id="nextQR" style="display:none;">Next QR â–¶</button>
<textarea id="manualBox" placeholder="Manual offer/answer text (if QR fails)"></textarea>

<canvas id="scanCanvas" hidden></canvas>

<script>
const cameraBtn = document.getElementById('cameraBtn');
const monitorBtn = document.getElementById('monitorBtn');
const qrDiv = document.getElementById('qr');
const manualBox = document.getElementById('manualBox');
const prevQR = document.getElementById('prevQR');
const nextQR = document.getElementById('nextQR');
const localVideo = document.getElementById('localVideo');
const remoteVideo = document.getElementById('remoteVideo');
const scanCanvas = document.getElementById('scanCanvas');

let pcCamera, pcMonitor;
const servers = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

// QR chunking
let qrChunks = [];
let currentQRIndex = 0;

cameraBtn.onclick = startCameraMode;
monitorBtn.onclick = startMonitorMode;
prevQR.onclick = () => showQRChunk(currentQRIndex - 1);
nextQR.onclick = () => showQRChunk(currentQRIndex + 1);

async function startCameraMode() {
  clearUI();
  const stream = await navigator.mediaDevices.getUserMedia({ video:true,audio:true });
  localVideo.srcObject = stream;

  pcCamera = new RTCPeerConnection(servers);
  stream.getTracks().forEach(t => pcCamera.addTrack(t, stream));

  pcCamera.onicecandidate = e => {
    if (e.candidate === null) {
      const offer = JSON.stringify(pcCamera.localDescription);
      generateChunks(offer);
    }
  };

  const offer = await pcCamera.createOffer();
  await pcCamera.setLocalDescription(offer);
}

async function startMonitorMode() {
  clearUI();
  pcMonitor = new RTCPeerConnection(servers);
  pcMonitor.ontrack = e => { remoteVideo.srcObject = e.streams[0]; };

  // Create video element for scanning and show it
  const scanVideo = document.createElement('video');
  scanVideo.setAttribute('playsinline', true);
  scanVideo.autoplay = true;
  scanVideo.muted = true;
  scanVideo.style.width = '90%';
  scanVideo.style.maxWidth = '480px';
  scanVideo.style.borderRadius = '6px';
  document.body.insertBefore(scanVideo, qrDiv); // above QR

  try {
    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
    scanVideo.srcObject = stream;
    await scanVideo.play(); // ensure camera is running

    // Canvas context with willReadFrequently
    const scanCtx = scanCanvas.getContext('2d', { willReadFrequently: true });

    let scannedChunks = [];

    async function scanLoop() {
      if (scanVideo.readyState === scanVideo.HAVE_ENOUGH_DATA) {
        scanCanvas.width = scanVideo.videoWidth;
        scanCanvas.height = scanVideo.videoHeight;
        scanCtx.drawImage(scanVideo, 0, 0, scanCanvas.width, scanCanvas.height);
        const imgData = scanCtx.getImageData(0, 0, scanCanvas.width, scanCanvas.height);
        const code = jsQR(imgData.data, imgData.width, imgData.height);
        if(code){
          scannedChunks.push(code.data);
          console.log("Scanned QR chunk", scannedChunks.length);
          alert(`Scanned chunk ${scannedChunks.length}. Scan next QR or finish.`);
          const done = confirm("Finished scanning all QR chunks?");
          if(done){
            stream.getTracks().forEach(t => t.stop());
            scanVideo.remove();
            const fullText = scannedChunks.join('');
            applyOffer(fullText);
            return;
          }
        }
      }
      requestAnimationFrame(scanLoop);
    }

    scanLoop();
  } catch(err){
    console.error("Camera for scanning not available:", err);
    alert("Camera not available or permission denied: " + err.message);
  }
}

function clearUI() {
  qrDiv.innerHTML="";
  manualBox.value="";
  qrChunks=[];
  currentQRIndex=0;
  prevQR.style.display="none";
  nextQR.style.display="none";
}

function generateChunks(text){
  const compressed = LZString.compressToEncodedURIComponent(text);
  const chunkSize = 800;
  qrChunks=[];
  for(let i=0;i<compressed.length;i+=chunkSize){
    qrChunks.push(compressed.slice(i,i+chunkSize));
  }
  currentQRIndex=0;
  showQRChunk(currentQRIndex);
  console.log("QR chunks generated:", qrChunks.length);
  manualBox.value = compressed; // fallback
}

function showQRChunk(index){
  if(index<0||index>=qrChunks.length) return;
  qrDiv.innerHTML="";
  new QRCode(qrDiv,{text:qrChunks[index],width:220,height:220,correctLevel:QRCode.CorrectLevel.M});
  currentQRIndex=index;
  prevQR.style.display=(currentQRIndex>0)?"inline":"none";
  nextQR.style.display=(currentQRIndex<qrChunks.length-1)?"inline":"none";
}

// Apply Offer (monitor)
async function applyOffer(qrData){
  try{
    const jsonText = LZString.decompressFromEncodedURIComponent(qrData);
    const offer = JSON.parse(jsonText);
    await pcMonitor.setRemoteDescription(offer);
    const answer = await pcMonitor.createAnswer();
    await pcMonitor.setLocalDescription(answer);
    generateChunks(JSON.stringify(pcMonitor.localDescription));
  } catch(err){ console.error(err); alert(err); }
}

// Apply Answer (camera)
manualBox.addEventListener('change', async ()=>{
  const txt=manualBox.value.trim();
  if(!txt) return;
  if(pcCamera&&!pcCamera.remoteDescription){
    try{
      const jsonText=LZString.decompressFromEncodedURIComponent(txt);
      const answer = JSON.parse(jsonText);
      await pcCamera.setRemoteDescription(answer);
    } catch(err){ console.error(err); alert(err);}
  }
});
</script>
</body>
</html>
